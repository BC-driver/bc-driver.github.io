<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>BCBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="BCBlog">
<meta property="og:url" content="https://bc-driver.github.io/index.html">
<meta property="og:site_name" content="BCBlog">
<meta property="og:locale">
<meta property="article:author" content="BCDriver">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="BCBlog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BCBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Be greater</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://bc-driver.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-网络流之最大流问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-02-11T07:07:49.106Z" itemprop="datePublished">2023-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络流之最大流问题-徐子睿"><a href="#网络流之最大流问题-徐子睿" class="headerlink" title="网络流之最大流问题 - 徐子睿"></a>网络流之最大流问题 - 徐子睿</h1><h1 id="1-算法的引入"><a href="#1-算法的引入" class="headerlink" title="1 算法的引入"></a>1 算法的引入</h1><h2 id="UNIX插座"><a href="#UNIX插座" class="headerlink" title="UNIX插座"></a>UNIX插座</h2><p>有 n 个插座，m 个设备和 k (n,m,k≤100) 种转换器，每种转换器有无限多。已知每个插座的类型，每个设备的插头类型，以及每种转换器的插座类型和插头类型。插头和插座类型都用不超过 24 个字母表示，插座只能插到类型名称相同的插座中。 例如，有 4 个插座，类型分别为 A，B，C，D；有 5 个设备，插头类型分别为 B，C，B，B，X；还有三种转换器，分别是 B-&gt;X，X-&gt;A 和 X-&gt;D。这里用 B -&gt; X 表示插座类型为 B，插头类型为 X，因此一个插座类型为 B 的设备插上这种转换器之后就 “变成” 了一个插头类型为 X 的设备。转换器可以级联使用，例如插头类型为 A 的设备依次接上 A-&gt;B, B-&gt;C, C-&gt;D 这 3 个转换器之后会 “变成” 插头类型为 D 的设备。 要求插的设备尽量多。问最少剩几个不匹配的设备。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>题目中提到每种转换器都有无限多个，所以我们可以预处理出每个插头可以转换出的插头类型。<br><br>这部分的预处理，考虑到 n,m,k≤100 ，即使所有的插头、设备、转换器都不同最多也只可能有400种不同的名字（而这种情况显然是无解的），我们可以用Floyd算法算出转换器之间的传递闭包来处理转换器之间的可转换关系 <br><br>接下来的问题就是如何<strong>分配</strong>各个插头（可能是转换后的）<br><br>而这就需要我们下面的模型——网络流。它就是专门来处理<strong>分配问题</strong>的模型</p>
<h1 id="2-1-网络流"><a href="#2-1-网络流" class="headerlink" title="2.1 网络流"></a>2.1 网络流</h1><p>在一个有向图上选择一个源点，一个汇点，每一条边上都有一个流量上限（以下称为容量），即经过这条边的流量不能超过这个上界，同时，除源点和汇点外，所有点的入流和出流都相等，而源点只有流出的流，汇点只有汇入的流。这样的图叫做网络流。</p>
<blockquote>
<p>所谓网络或容量网络指的是一个连通的赋权有向图 D &#x3D; （V、E、C） ， 其中V 是该图的顶点集，E是有向边(即弧)集，C是弧上的容量。此外顶点集中包括一个起点和一个终点。网络上的流就是由起点流向终点的可行流，这是定义在网络上的非负函数，它一方面受到容量的限制，另一方面除去起点和终点以外，在所有中途点要求保持流入量和流出量是平衡的。（引自百度百科）<br></p>
</blockquote>
<p><img src="https://i.328888.xyz/2023/01/16/2gBMC.png" alt="2gBMC.png"></p>
<p>上图中1为源点，6为汇点<br><br>为了下面讲解方便，我们引入如下几个概念：<br></p>
<ol>
<li>源点$S$：只有流出去的点</li>
<li>汇点$T$：只有流进来的点</li>
<li>流量$Flow$：一条边上流过的流量</li>
<li>容量$Capacity$：一条边上可供流过的最大流量</li>
<li>残量$Rest$：一条边上的 容量 - 流量</li>
</ol>
<p>网络流图中有这样三个重要的性质值得我们注意：<br></p>
<ol>
<li>对任意一条边，总有 $Flow &lt; Capacity$</li>
<li>对任意一个非S&#x2F;T点u总有 $\sum^{}<em>{p \in V} flow[p][u] \equiv \sum^{}</em>{v \in V} flow[u][v]$ (即这个点的入流与出流相等)</li>
<li>对任意一个有向边(u, v)总有$flow[u][v] \equiv -flow[v][u]$</li>
</ol>
<h1 id="2-2-最大流问题"><a href="#2-2-最大流问题" class="headerlink" title="2.2 最大流问题"></a>2.2 最大流问题</h1><p>最大流问题就是求一个网络中S-T流量的最大值。</p>
<h2 id="2-2-1Edmonds-Karp算法"><a href="#2-2-1Edmonds-Karp算法" class="headerlink" title="2.2.1Edmonds-Karp算法"></a>2.2.1Edmonds-Karp算法</h2><p>Edmonds-Karp算法基于增广路定理，下面我们介绍该定理：<br><br>我们计算每条边上的残量，得到原网络的<strong>残量网络</strong><br><br>残量网络中任意一条s-t通路都能够对应原图中的一条<strong>增广路</strong>。而这条道路上的最小残量就是这条通路上可以增大的流量。<br><br>自然的，若残量网络中不存在增广路时，原网络即达到最大流</p>
<p>基于这个定理，我们便可以设计出相应的算法算出网络中的最大流，即Edmonds-Karp算法。</p>
<p>在EK算法中我们在加入正向边的同时，又加入了一条反向的、capacity为0的反向边，这样做的原因是如果我们在增广的时候找到的增广路并不是最优解的话，反向边的存在可以使得从其他路流经这条边时，可以通过流过他的反向边来<strong>撤销</strong>把这条边作为增广路的决策。</p>
<p>我们给出一个例子：<br><img src="https://i.328888.xyz/2023/01/17/2PfwL.png" alt="2PfwL.png"><br>若是一开始我们增广的决策是 u -&gt; v</p>
<p>而实际上的最优解是u -&gt; q;p -&gt; v;</p>
<p>那么我们就可以通过增广到p时走u -&gt; v的反向边来撤销u -&gt; v上原有的流。</p>
<p>当然，这种<strong>撤销</strong>也可以是不完全的，如果我们的最优解需要u,p同时对v输入流量的话，也可以只撤销一部分的u -&gt; v流。</p>
<p>下面给出完整的代码并配有细节讲解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EdmondsKarp</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        </span><br><span class="line">    vector &lt;edge&gt; edges;           <span class="comment">//存储边</span></span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; g[maxn];          <span class="comment">//存储以某节点为起点的边序号</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;     </span><br><span class="line">    <span class="type">int</span> pre[maxn], adv[maxn];      <span class="comment">//pre存储某节点增广路上的入弧</span></span><br><span class="line">                                   <span class="comment">//adv存储由s到该点的最小余量（可改进量）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;u, v, c, <span class="number">0</span>&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;v, u, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> i = edges.<span class="built_in">size</span>();</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(i - <span class="number">2</span>);      <span class="comment">//正向边</span></span><br><span class="line">        g[v].<span class="built_in">push_back</span>(i - <span class="number">1</span>);      <span class="comment">//反向边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;      <span class="comment">//BFS搜索增广路</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(adv, <span class="number">0</span>, <span class="built_in">sizeof</span>(adv));</span><br><span class="line">            <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">            queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">            q.<span class="built_in">push</span>(s);</span><br><span class="line">            adv[s] = inf;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">                        edge &amp;e = edges[i];         <span class="comment">//用引用减少代码量，增加可读性</span></span><br><span class="line">                    <span class="keyword">if</span>(!adv[e.v] &amp;&amp; e.c &gt; e.f)&#123;     </span><br><span class="line">                        <span class="comment">//若capacity &gt; flow则说明这条边在残量网络中可以是增广路，将其记录</span></span><br><span class="line">                        <span class="comment">//adv可以同时充当vis数组的作用</span></span><br><span class="line">                        adv[e.v] = <span class="built_in">min</span>(adv[e.u], e.c - e.f); <span class="comment">//计算可改进量</span></span><br><span class="line">                        pre[e.v] = i;               <span class="comment">//记录入弧</span></span><br><span class="line">                        q.<span class="built_in">push</span>(e.v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(adv[t]) <span class="keyword">break</span>;   <span class="comment">//一旦搜索到t点，则代表增广路已经找到</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!adv[t]) <span class="keyword">break</span>;      <span class="comment">//若已经没有增广路，则已找到最大流</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v = t;v != s;v = edges[pre[v]].u)&#123;</span><br><span class="line">                    edge &amp;e = edges[pre[v]], &amp;einv = edges[pre[v] ^ <span class="number">1</span>];</span><br><span class="line">                    e.f += adv[v]; </span><br><span class="line">                    einv.f -= adv[v];</span><br><span class="line">                &#125;</span><br><span class="line">                res += adv[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：</p>
<p>每增广一次，层次网络中必定有一条边会被删除。层次网络中最多有m条边，所以认为最多可以增广m次。在最短增广路算法中，用BFS来增广，一次增广的复杂度为$O(n+m)$，其中$O(m)$为BFS的花费，$O(n)$为修改流量的花费。所以在每一阶段寻找增广路的复杂度为$O(m(m+n)) &#x3D; O(m^2)$。因此n个阶段寻找增广路的算法总复杂度为$O(nm^2)$。</p>
<p>EK算法虽然可以计算出网络中的最大流，但其有一些有待改进的地方：</p>
<p>在搜索过程中，一旦搜索到t点的增广路就退出循环，浪费了对未搜索到的增广路的计算。有大量的计算冗余。</p>
<p>下面我们来看一个例子来更好地理解这一点</p>
<p><img src="https://i.328888.xyz/2023/01/17/2L1VZ.png" alt="2L1VZ.png"></p>
<p>我们有一个图，如图一。</p>
<p>按照套路，我们先BFS，找S−T最短路。所有的距离标号都画在了图二上（EK算法可能用不到，但Dinic用得到）。</p>
<p>假设我们选的是S−3−T这条路，增广（如图三，绿色）</p>
<p>然后我们再来一遍BFS。。。 等等！</p>
<p>细心的你可能也发现了，S−1−T也是一条S−T最短路。</p>
<p>那就增广吧！（如图四）</p>
<p>可以检查一下，这时候没有长度为2的最短路了。</p>
<p>但EK算法不会这样。它会再笨拙地BFS一遍，这就浪费了不少时间。</p>
<p>所以说，多路增广是很重要的。</p>
<p>故我们需要找到一个新的算法，让其在一次循环内多找出几条增广路，避免己经计算出的数据的浪费。</p>
<h2 id="2-2-2-Dinic算法"><a href="#2-2-2-Dinic算法" class="headerlink" title="2.2.2 Dinic算法"></a>2.2.2 Dinic算法</h2><p>在Dinic算法中，我们引入了分层图这一概念，更具体地，我们先计算出各节点到s点的无权最短路并将其记录为该点的层次，且最短路上的边必须可以增广，这一步相当于把网络中的节点分成不同的层。<br>而当t点的层次不存在时则意味着没有从s到t的增广路，此时最大流已经找到</p>
<p>与EK算法不同的是，当我们用BFS计算出网络的分层图后，对于增广路的搜索我们用的是DFS。DFS时，可以继续搜索的条件就是v的层次比u大1.</p>
<p>为什么只能大1呢，回到我们BFS时，我们在分层图中计算的是各节点到s点的无权<strong>最短路</strong>，所以层次差超过2的一对点（u， v）直接相连的情况是不存在的，因为如果这样的点对真的存在，那么在距离为1的u，v中，u、v到s的最短路长度竟然差了不止1，这样显然是错误的。</p>
<p>下面给出代码并进行细节讲解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dinic</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    vector &lt;edge&gt; edges;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; g[maxn];</span><br><span class="line">    <span class="type">int</span> level[maxn];                <span class="comment">//存储节点层次</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;u, v, c, <span class="number">0</span>&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;v, u, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> i = edges.<span class="built_in">size</span>();</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(i - <span class="number">2</span>);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">        queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        level[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">                edge &amp;e = edges[i];</span><br><span class="line">                <span class="keyword">if</span>(e.c &gt; e.f &amp;&amp; level[e.v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//只有增广路存在时才能分配层次</span></span><br><span class="line">                    level[e.v] = level[e.u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!level[t]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若t点层次不存在则说明没有s-&gt;t增广路，返回false退出循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> adv, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t) <span class="keyword">return</span> adv; <span class="comment">//搜索到t点代表已经找到增广路，返回可改进量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">            edge &amp;e = edges[i], &amp;einv = edges[i ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(level[e.v] == level[e.u] + <span class="number">1</span> &amp;&amp; e.c &gt; e.f)&#123;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">DFS</span>(e.v, <span class="built_in">min</span>(adv, e.c - e.f), t);</span><br><span class="line">                <span class="keyword">if</span>(res &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    e.f += res;</span><br><span class="line">                    einv.f -= res;</span><br><span class="line">                    <span class="keyword">return</span> adv;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">BFS</span>(s, t))&#123;                       <span class="comment">//只要t节点的层次存在则还有增广路</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="type">int</span> adv = <span class="built_in">DFS</span>(s, inf, t))&#123;    <span class="comment">//DFS搜索出增广路返回总可改进量</span></span><br><span class="line">                res += adv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：</p>
<p>Dinic算法最多被分为n个阶段，这是因为每次建立层次图后t的层次是严格递增的。</p>
<p>现在来分析DFS过程的总复杂度。在每一阶段，将DFS分成两部分分析。</p>
<ol>
<li><p>修改增广路的流量并后退的花费。在每一阶段，最多增广m次，每次修改流量的费用为$O(n)$。而一次增广后在增广路中后退的费用也为$O(n)$。所以在每一阶段中，修改增广路以及后退的复杂度为$O(nm)$。</p>
</li>
<li><p>DFS遍历时的前进与后退。在DFS遍历时，如果当前路径的最后一个顶点能够继续扩展，则一定是沿着第i层的顶点指向第i+1层顶点的边向汇点前进了一步。因为增广路经长度最长为n，所以最坏的情况下前进n步就会遇到汇点。在前进的过程中，可能会遇到没有边能够沿着继续前进的情况，这时将路径中的最后一个点在层次图中删除。</p>
<p> 注意到每后退一次必定会删除一个顶点，所以后退的次数最多为n次。在每一阶段中，后退的复杂度为$O(n)$。</p>
<p> 假设在最坏的情况下，所有的点最后均被退了回来，一共共后退了n次，这也就意味着，有n次的前进被“无情”地退了回来，这n次前进操作都没有起到“寻找增广路”的作用。除去这n次前进和n次后退，其余的前进都对最后找到增广路做了贡献。增广路最多找到m次。每次最多前进n个点。所以所有前进操作最多为n+m*n次，复杂度为$O(nm)$。</p>
</li>
</ol>
<p>于是得到，在每一阶段中，DFS遍历时前进与后退的花费为$O(nm)$。</p>
<p>综合以上两点，一次DFS的复杂度为$O(nm)$。因此，Dinic算法的总复杂度即$O(n ^ 2 m)$。</p>
<p>当然，Dinic算法可以再被优化：</p>
<p>注意到当我们在一次DFS是如果搜索到了一条增广路，我们要回退到s点再重新寻找增广路，而这时我们仍可能搜索到之前已经增广过的路线，所以我们引入<strong>当前弧</strong>这一概念，用一个数组cur记录点u之前循环到了哪一条边，以此来加速避免重复的寻找同一条边。</p>
<p>优化后代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dinic</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    vector &lt;edge&gt; edges;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; g[maxn];</span><br><span class="line">    <span class="type">int</span> level[maxn], cur[maxn];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;u, v, c, <span class="number">0</span>&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;v, u, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> i = edges.<span class="built_in">size</span>();</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(i - <span class="number">2</span>);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setN</span><span class="params">(<span class="type">int</span> N)</span></span>&#123;</span><br><span class="line">        n = N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">        queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        level[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">                edge &amp;e = edges[i];</span><br><span class="line">                <span class="keyword">if</span>(e.c &gt; e.f &amp;&amp; level[e.v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    level[e.v] = level[e.u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!level[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFSAdv</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> adv, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t) <span class="keyword">return</span> adv;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i = cur[u];i &lt; g[u].<span class="built_in">size</span>();i++)&#123;  <span class="comment">//引用使得i变化时同时改变u点的当前弧</span></span><br><span class="line">            edge &amp;e = edges[g[u][i]], &amp;einv = edges[g[u][i] ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(level[e.v] == level[e.u] + <span class="number">1</span> &amp;&amp; e.c &gt; e.f)&#123;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">DFS</span>(e.v, <span class="built_in">min</span>(adv, e.c - e.f), t);</span><br><span class="line">                <span class="keyword">if</span>(res &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    e.f += res;</span><br><span class="line">                    einv.f -= res;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFlowAdv</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">BFS</span>(s, t))&#123;</span><br><span class="line">            <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in">sizeof</span>(cur)); <span class="comment">// 在新层次图上搜索时要重置当前弧</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="type">int</span> adv = <span class="built_in">DFSAdv</span>(s, inf, t))&#123;</span><br><span class="line">                res += adv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-引入题的解答"><a href="#3-引入题的解答" class="headerlink" title="3 引入题的解答"></a>3 引入题的解答</h1><p>有了上面算法的介绍，我们便可以设计出UNIX插头问题的代码了</p>
<ol>
<li>首先用Floyd计算出转换器的传递闭包</li>
<li>接下来构造网络，令第i个设备的插头为plug[i]，第i个插座为in[i]。<br>构造s点，对于每一个设备都连接一条s到plug[i]，capacity为1的边；构造t点，对于每一个插座都连接一条in[i]到t，capacity为1的边；对于每个plug[i]，连接一条capacity为inf的边到其可以转换的插座上</li>
<li>以上网络的最大流即为最多的匹配插头，用总数减去最大流即为最小剩余插头。</li>
</ol>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> KASE;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, c, f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dinic</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    vector &lt;edge&gt; edges;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; g[maxn];</span><br><span class="line">    <span class="type">int</span> level[maxn], cur[maxn];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;u, v, c, <span class="number">0</span>&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;v, u, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> i = edges.<span class="built_in">size</span>();</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(i - <span class="number">2</span>);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">        queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        level[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">                edge &amp;e = edges[i];</span><br><span class="line">                <span class="keyword">if</span>(e.c &gt; e.f &amp;&amp; level[e.v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    level[e.v] = level[e.u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!level[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> adv, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t) <span class="keyword">return</span> adv;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">            edge &amp;e = edges[i], &amp;einv = edges[i ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(level[e.v] == level[e.u] + <span class="number">1</span> &amp;&amp; e.c &gt; e.f)&#123;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">DFS</span>(e.v, <span class="built_in">min</span>(adv, e.c - e.f), t);</span><br><span class="line">                <span class="keyword">if</span>(res &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    e.f += res;</span><br><span class="line">                    einv.f -= res;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">BFS</span>(s, t))&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="type">int</span> adv = <span class="built_in">DFS</span>(s, inf, t))&#123;</span><br><span class="line">                res += adv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> plugCnt, inCnt, convertCnt;</span><br><span class="line">    vector &lt;string&gt; name;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; plugs, ins;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    map &lt;string, <span class="type">int</span>&gt; idx;</span><br><span class="line">    cin&gt;&gt;inCnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; inCnt;i++)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(!idx[s])&#123;</span><br><span class="line">            name.<span class="built_in">push_back</span>(s);</span><br><span class="line">            idx[s] = name.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ins.<span class="built_in">push_back</span>(idx[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;plugCnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; plugCnt;i++)&#123;</span><br><span class="line">        string temp, s;</span><br><span class="line">        cin&gt;&gt;temp&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(!idx[s])&#123;</span><br><span class="line">            name.<span class="built_in">push_back</span>(s);</span><br><span class="line">            idx[s] = name.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        plugs.<span class="built_in">push_back</span>(idx[s]);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;convertCnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; convertCnt;i++)&#123;</span><br><span class="line">        string u, v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(!idx[u])&#123;</span><br><span class="line">            name.<span class="built_in">push_back</span>(u);</span><br><span class="line">            idx[u] = name.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!idx[v])&#123;</span><br><span class="line">            name.<span class="built_in">push_back</span>(v);</span><br><span class="line">            idx[v] = name.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        d[idx[u]][idx[v]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>;k &lt;= name.<span class="built_in">size</span>() + <span class="number">1</span>;k++) d[k][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>;k &lt;= name.<span class="built_in">size</span>() + <span class="number">1</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= name.<span class="built_in">size</span>() + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt;= name.<span class="built_in">size</span>() + <span class="number">1</span>;j++)&#123;</span><br><span class="line">                d[i][j] = d[i][j] || (d[i][k] &amp;&amp; d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> S = name.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> s = <span class="number">1</span>, t = S + <span class="number">2</span>;</span><br><span class="line">    Dinic D;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : plugs)&#123;</span><br><span class="line">        D.<span class="built_in">addedge</span>(s, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : ins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i][j])&#123;</span><br><span class="line">                D.<span class="built_in">addedge</span>(i, j + S + <span class="number">1</span>, inf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i :ins)&#123;</span><br><span class="line">        D.<span class="built_in">addedge</span>(i + S + <span class="number">1</span>, t, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;plugs.<span class="built_in">size</span>() - D.<span class="built_in">maxFlow</span>(s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;KASE;</span><br><span class="line">    <span class="keyword">while</span>(KASE)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(--KASE) cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-例题"><a href="#4-例题" class="headerlink" title="4 例题"></a>4 例题</h1><p>通过这道题我们可以更好地理解网络流是如何解决<strong>分配</strong>问题的。</p>
<h2 id="UVA11082-矩阵解压-Matrix-Decompressing"><a href="#UVA11082-矩阵解压-Matrix-Decompressing" class="headerlink" title="UVA11082 矩阵解压 Matrix Decompressing"></a>UVA11082 矩阵解压 Matrix Decompressing</h2><p>已知一矩阵的行数$R$与列数$C$，以及前$i$行的前缀和$a_i$、前$j$列的前缀和$b_j$，矩阵元素的取值为$1-20$求一合法矩阵。</p>
<h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>由前缀和我们可以反向得到每一行、列的元素和。</p>
<p>值得注意的是，每一列的元素都分别属于不同的行，更抽象的说，这一列的元素在列上<strong>汇聚</strong>到了一起又<strong>分配</strong>给了各行，如下图所示</p>
<p><img src="https://i.328888.xyz/2023/01/17/2aatE.jpeg" alt="2aatE.jpeg"></p>
<p>这启示了我们也许可以用网络流来进行元素的分配</p>
<p>还有一个小问题，网络流中允许的最小流量是0，但题目要求最少是1</p>
<p>对于这个问题，我们可以把每个colsum 减去 R，rowsum 减去 C。这样处理之后元素的取值范围就变成了0-19，可以构造网络流。</p>
<p>那么本题的思路就已经基本出来了</p>
<ol>
<li>计算每行、列的元素和$rowsum[R]$,$colsum[C]$（元素取值范围为0-19）;</li>
<li>构建网络，构造源点$s$，对于每个行索引$i$连接一条$s$到$i$、$capacity$为$colsum[i]$的边；构造汇点t，对于每个列索引j连接一条$j$到$t$、$capacity$为$rowsum[j]$的边；对于每个$i$，对所有$j$连接一条$i$到$j$，$capacity$为$19$的边</li>
<li>计算网络的最大流，如果最大流等于所有元素之和则有解，且第$i$行第$j$列元素即为从$i$到$j$边上的$flow$。</li>
</ol>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> KASE, T;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u, v, c, f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dinic</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector &lt;edge&gt; edges;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; g[maxn];</span><br><span class="line">    <span class="type">int</span> level[maxn] = &#123;<span class="number">0</span>&#125;, cur[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;u, v, c, <span class="number">0</span>&#125;);</span><br><span class="line">        edges.<span class="built_in">push_back</span>((edge)&#123;v, u, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="type">int</span> i = edges.<span class="built_in">size</span>();</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(i - <span class="number">2</span>);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(level, <span class="number">0</span>, <span class="built_in">sizeof</span>(level));</span><br><span class="line">        queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        level[s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">                edge &amp;e = edges[i];</span><br><span class="line">                <span class="keyword">if</span>(e.c &gt; e.f &amp;&amp; level[e.v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    level[e.v] = level[e.u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!level[t]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> adv, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == t) <span class="keyword">return</span> adv;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : g[u])&#123;</span><br><span class="line">            edge &amp;e = edges[i], &amp;einv = edges[i ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(level[e.v] == level[e.u] + <span class="number">1</span> &amp;&amp; e.c &gt; e.f)&#123;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">DFS</span>(e.v, <span class="built_in">min</span>(adv, e.c - e.f), t);</span><br><span class="line">                <span class="keyword">if</span>(res &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    e.f += res;</span><br><span class="line">                    einv.f -= res;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">BFS</span>(s, t))&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="type">int</span> adv = <span class="built_in">DFS</span>(s, inf, t))&#123;</span><br><span class="line">                res += adv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> R, C;</span><br><span class="line">    cin&gt;&gt;R&gt;&gt;C;</span><br><span class="line">    <span class="type">int</span> rowsum[maxn] = &#123;<span class="number">0</span>&#125;, colsum[maxn] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= R;i++) cin&gt;&gt;rowsum[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = R;i &gt;= <span class="number">1</span>;i--) rowsum[i] -= (rowsum[i - <span class="number">1</span>] + C);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= C;i++) cin&gt;&gt;colsum[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C;i &gt;= <span class="number">1</span>;i--) colsum[i] -= (colsum[i - <span class="number">1</span>] + R);</span><br><span class="line">    Dinic D;</span><br><span class="line">    <span class="type">int</span> s = R + C + <span class="number">1</span>, t = R + C + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= R;i++)&#123;</span><br><span class="line">        D.<span class="built_in">addedge</span>(s, i, rowsum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= C;i++)&#123;</span><br><span class="line">        D.<span class="built_in">addedge</span>(i + R, t, colsum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= R;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= C;j++)&#123;</span><br><span class="line">            D.<span class="built_in">addedge</span>(i, j + R, <span class="number">19</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    D.<span class="built_in">maxFlow</span>(s, t);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Matrix &quot;</span>&lt;&lt;T - KASE + <span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= R;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= C;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> k : D.g[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(D.edges[k].v == j + R)&#123;</span><br><span class="line">                    cout&lt;&lt;D.edges[k].f + <span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;KASE;</span><br><span class="line">    T = KASE;</span><br><span class="line">    <span class="keyword">while</span>(KASE)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">if</span>(KASE--) cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://bc-driver.github.io/2023/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/" data-id="cldzm8q7h000074qm3gipg49s" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/02/11/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%B9%8B%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 BCDriver<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>